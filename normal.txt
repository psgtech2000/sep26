# -*- coding: utf-8 -*-
"""DPS_CA2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Aruz5he6ocsg4o_24qr2-UgKkdgd6eIt

# **SETUP.PY**
"""

import subprocess
from pathlib import Path

def run(cmd):
    subprocess.run(cmd, check=True)

def setup_ca():
    # Create demoCA structure

    #not necessarily needed this demoCA folder creation - just setup
    # Path("demoCA/certs").mkdir(parents=True, exist_ok=True)
    # Path("demoCA/crl").mkdir(exist_ok=True)
    # Path("demoCA/newcerts").mkdir(exist_ok=True)
    # Path("demoCA/private").mkdir(exist_ok=True)
    # Path("demoCA/index.txt").write_text("")
    # Path("demoCA/serial").write_text("1000")

    if not Path("ca.key").exists():
        run(["openssl", "genrsa", "-out", "ca.key", "4096"])
        run([
            "openssl", "req", "-new", "-x509", "-days", "365",
            "-key", "ca.key", "-out", "ca.crt",
            "-subj", "/CN=MyRootCA"
        ])
        print("Root CA created.")

def issue_cert(name):
    run(["openssl", "genrsa", "-out", f"{name}.key", "2048"])
    run([
        "openssl", "req", "-new", "-key", f"{name}.key", "-out", f"{name}.csr",
        "-subj", f"/CN={name}.local"
    ])
    run([
        "openssl", "x509", "-req", "-in", f"{name}.csr", "-CA", "ca.crt", "-CAkey", "ca.key",
        "-CAcreateserial", "-out", f"{name}.crt", "-days", "365"
    ])
    print(f"{name}.crt issued by CA.")

# Run setup directly
setup_ca()
issue_cert("server")
issue_cert("client")

"""# **SERVER.PY**"""

import socket, subprocess, tempfile, time
from pathlib import Path

HOST, PORT = "127.0.0.1", 5000
SERVER_KEY = "server.key"
SERVER_CERT = "server.crt"
CA_CERT = "ca.crt"

def run(cmd):
    return subprocess.run(cmd, capture_output=True, check=True).stdout

def wait_for_file(file_path, timeout=30):
    start = time.time()
    while not Path(file_path).exists():
        if time.time() - start > timeout:
            raise TimeoutError(file_path + " not found in " + str(timeout) + " seconds")
        time.sleep(0.5)

def rsa_decrypt(ciphertext: bytes) -> bytes:
    f = tempfile.NamedTemporaryFile(delete=False)
    f.write(ciphertext)
    f.flush()
    f.close()
    decrypted = run(["openssl", "rsautl", "-decrypt", "-inkey", SERVER_KEY, "-in", f.name])
    return decrypted

def verify_signature(message: bytes, signature: bytes, client_cert: str) -> bool:
    pubkey_file = "client_pub.pem"
    subprocess.run(
        ["openssl", "x509", "-in", client_cert, "-pubkey", "-noout"],
        stdout=open(pubkey_file, "wb"), check=True
    )
    f_msg = tempfile.NamedTemporaryFile(delete=False)
    f_sig = tempfile.NamedTemporaryFile(delete=False)
    f_msg.write(message); f_msg.flush(); f_msg.close()
    f_sig.write(signature); f_sig.flush(); f_sig.close()
    result = subprocess.run(
        ["openssl", "dgst", "-sha256", "-verify", pubkey_file, "-signature", f_sig.name, f_msg.name],
        capture_output=True
    )
    return b"Verified OK" in result.stdout

def verify_cert(cert_file: str) -> bool:
    result = subprocess.run(
        ["openssl", "verify", "-CAfile", CA_CERT, cert_file],
        capture_output=True
    )
    return b"OK" in result.stdout

# Server code starts directly
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen(1)
    print("Server listening...")
    conn, addr = s.accept()
    with conn:
        print("Connected:", addr)

        # Send server certificate
        cert_data = Path(SERVER_CERT).read_bytes()
        conn.sendall(len(cert_data).to_bytes(4, "big") + cert_data)

        # Receive client certificate
        length = int.from_bytes(conn.recv(4), "big")
        client_cert = conn.recv(length)
        client_cert_file = "client.crt"
        Path(client_cert_file).write_bytes(client_cert)

        if not verify_cert(client_cert_file):
            print("Client certificate not trusted.")
        else:
            print("Client certificate verified.")

            # Receive ciphertext
            length = int.from_bytes(conn.recv(4), "big")
            ciphertext = conn.recv(length)

            # Receive signature
            length = int.from_bytes(conn.recv(4), "big")
            signature = conn.recv(length)

            plaintext = rsa_decrypt(ciphertext)
            print("Message:", plaintext.decode())

            ok = verify_signature(plaintext, signature, client_cert_file)
            print("Signature:", "OK" if ok else "Failed")

"""# **CLIENT.PY**"""

import socket, subprocess, tempfile
from pathlib import Path

HOST, PORT = "127.0.0.1", 5000
CLIENT_KEY = "client.key"
CLIENT_CERT = "client.crt"
CA_CERT = "ca.crt"

def run(cmd):
    return subprocess.run(cmd, capture_output=True, check=True).stdout

def rsa_encrypt(data: bytes, pubkey_file: str) -> bytes:
    with tempfile.NamedTemporaryFile(delete=False) as f:
        f.write(data)
        f.flush()
        return run(["openssl", "rsautl", "-encrypt", "-inkey", pubkey_file, "-pubin", "-in", f.name])

def sign_message(message: bytes) -> bytes:
    with tempfile.NamedTemporaryFile(delete=False) as f_msg, tempfile.NamedTemporaryFile(delete=False) as f_sig:
        f_msg.write(message)
        f_msg.flush()
        subprocess.run(
            ["openssl", "dgst", "-sha256", "-sign", CLIENT_KEY, "-out", f_sig.name, f_msg.name],
            check=True
        )
        return Path(f_sig.name).read_bytes()

def verify_cert(cert_file: str) -> bool:
    result = subprocess.run(
        ["openssl", "verify", "-CAfile", CA_CERT, cert_file],
        capture_output=True
    )
    return b"OK" in result.stdout

# --- Client workflow ---
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect((HOST, PORT))

    # Receive server certificate
    length = int.from_bytes(s.recv(4), "big")
    server_cert = s.recv(length)
    server_cert_file = "server.crt"
    Path(server_cert_file).write_bytes(server_cert)

    if not verify_cert(server_cert_file):
        print("Server certificate not trusted.")
        exit(1)
    print("Server certificate verified.")

    # Extract server public key
    subprocess.run(
        ["openssl", "x509", "-in", server_cert_file, "-pubkey", "-noout"],
        stdout=open("server_pub.pem", "wb"), check=True
    )

    # Send client certificate
    cert_data = Path(CLIENT_CERT).read_bytes()
    s.sendall(len(cert_data).to_bytes(4, "big") + cert_data)

    # Message to send
    message = b"Hello Server, this is Client!"
    # Or read from a small file:
    # with open("message.txt", "rb") as f:
    #     message = f.read()

    ciphertext = rsa_encrypt(message, "server_pub.pem")
    signature = sign_message(message)

    s.sendall(len(ciphertext).to_bytes(4, "big") + ciphertext)
    s.sendall(len(signature).to_bytes(4, "big") + signature)

    print("Message and signature sent.")

"""# **HYBRID - JUST SEE**

# If the file given for encryption and decryption is larger, we should go for hybrid encryption and decryption which uses AES + RSA

# **CLIENT SIDE CHANGES :**

Replace your current RSA encryption of the message:

ciphertext = rsa_encrypt(message, "server_pub.pem")

With hybrid steps:

import os

# Step 1: Generate random AES key (32 bytes for AES-256)
aes_key = os.urandom(32)
with open("aes_key.bin", "wb") as f:
    f.write(aes_key)

# Step 2: Encrypt message/file with AES
aes_encrypt_cmd = f"openssl enc -aes-256-cbc -salt -in message.txt -out message.enc -pass file:aes_key.bin"
subprocess.run(aes_encrypt_cmd, shell=True, check=True)

# Step 3: Encrypt AES key with server's RSA public key
rsa_encrypt_cmd = "openssl rsautl -encrypt -inkey server_pub.pem -pubin -in aes_key.bin -out aes_key.enc"
subprocess.run(rsa_encrypt_cmd, shell=True, check=True)

# Send 'aes_key.enc' and 'message.enc' to server


# **SERVER SIDE CHANGES:**

Replace your current RSA decryption of the message:

plaintext = rsa_decrypt(ciphertext)

With hybrid steps:

# Step 1: Decrypt AES key with server private key
rsa_decrypt_cmd = "openssl rsautl -decrypt -inkey server.key -in aes_key.enc -out aes_key.bin"
subprocess.run(rsa_decrypt_cmd, shell=True, check=True)

# Step 2: Decrypt message/file with AES key
aes_decrypt_cmd = "openssl enc -aes-256-cbc -d -in message.enc -out message_decrypted.txt -pass file:aes_key.bin"
subprocess.run(aes_decrypt_cmd, shell=True, check=True)

# Step 3: Read decrypted file
with open("message_decrypted.txt", "rb") as f:
    plaintext = f.read()
print("ðŸ“© Message:", plaintext.decode())
"""